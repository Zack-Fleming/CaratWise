---
title: "CaratWiseModel"
author: "Zackery Fleming, Jake Compton, Cristian Castro"
date: "2023-10-26"
output:
  html_document:
    css: styles.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
![Diamond Dimensions](DiamondImage.jpg)


## Introduction

The goal of our project is to predict the price of diamonds within 80% to 90% accuracy of the true price.  The audience that is most interested in our work consists of the buyers and sellers of diamonds.  The dataset that we use in this project comes from Kaggle. We begin by exploring and analyzing the dataset.  We then move onto data wrangling, testing models, and finally our results.  We conclude with an explanation of our findings. 


## Explanation of the Diamond Dataset

The diamond dataset consists of several attributes that may affect the price of a diamond.  Through analysis, we will determine what attributes are correlated with diamond prices. 

 - **Carat** refers to the weight of the diamond.  Each carat is equivalent to 0.2 grams.  
 - **Cut** describes how well the rough diamond is transformed into the finished diamond.  The ideal cut of a diamond is one that is symmetrical and glows well when exposed to ultra-violet light.  
 - **Color** refers to diamond's color. Colorless diamonds are of higher quality.  
 - **Clarity** of a diamond is defined as how clear a diamond is.  Clearer diamonds have less defects like cracks.  
 - **Depth** of a diamond refers to the depth from the top of diamond to the point at the base expressed as a percentage.  
 - **Table** is a percentage ratio of the top flat portion of the diamond to the thickness of the base point.  The ideal table range is between 52% and 62%.  
 - **Price** refers to the cost of the diamond in USD.  
 - **x** refers to the length of the diamond in millimeters.  
 - **y** refers to the width of the diamond in millimeters.  
 - **z** refers to the  depth of the diamond.       

We note several assumptions and concerns that we made about the data set.  Our first assumption is that the features of a diamond, such as clarity, color, and cut, are good predictors of price.  One limitation is that the data set does not explicitly state the type of cut of the diamonds.  Therefore, we are assuming that all of the diamonds are of the round type cut since the type of cut can dictate the favorability of some of the diamond features.  One ethical consideration is that diamond sellers could possibly try to control the diamond market based on our study findings. However, we find this scenario to be highly unlikely.           


## Importaing Libraries and Data

```{r}
library(tidyverse)  # data manipulation and wrangling
library(ggplot2)    # graphs and charts for data visualization
library(gridExtra)  # showing multiple plots next one another
library(reshape2)   # for reshaping matrices, for correlation matrix

# reading in data from csv file
diamonds_raw <- read_csv("diamonds.csv", col_names = TRUE, col_types = "ncccnnnnnn")
```


## Data Visualization

Now its a good time to look at the dataset, to see what we can expect. Charts and graphs is a great way to visually understand the dataset.

### Data Summary

Let's start with simply looking at the first few records, to get an idea of what we are looking at.
```{r}
head(diamonds_raw)
```


Now, let's look at a summary of the dataset, to see the ranges and medians of the columns, as well as if there are any missing/NULL values. 
```{r}
summary(diamonds_raw)
```
The summary shows that the dataset at least has no missing values, and that that some columns may have some outliers or erronious data. 


### Data Correlation

Now, let's look at the correlation of the columns of data. This can be done in multiple ways, 

First, we need to calculate the correlation matrix for the columns. This can be done using a built-in function of R, **cor()**.
```{r}
# filter the non numeric columns
corr_data <- diamonds_raw[, c(1,5:10)]

# calculate and print the resulting matrix
corr_matrix <- round(cor(corr_data), 2)
corr_matrix
```

Now, we need to **melt** the correlation matrix, using a function from the **reshape2** library. The **melt** function does a similar thing to **pivot_longer**.
```{r}
melted_corr_matrix <- melt(corr_matrix)
head(melted_corr_matrix)
```

Third, we use **ggplot2's geom_tile()** to graph the correlation matrix.
```{r}
ggplot(data = melted_corr_matrix, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile()
```


### Heatmaps of Data

In an effort to make this correlation matrix more readable, we can turn it into a heatmap. A heatmap is helpful, since it uses a different color negative and positive correlation. Also, the heatmap takes out the redundant info from the correlation matrix. We can also take the heatmap and make descisions of what columns to use and discard for the prediction models.

To convert our correlation matrix into a form that is helpful for the heatmap, we must define a couple of helper functions:
```{r}
# get the lower triangle of the matrix
calc_lower_Triangle <- function(corr_mat) {
  corr_mat[upper.tri(corr_mat)] <- NA
  return(corr_mat)
}

# get the upper triangle of the matrix
calc_upper_Triangle <- function(corr_mat) {
  corr_mat[lower.tri(corr_mat)] <- NA
  return(corr_mat)
}
```

After creating our helper functions, we can create a basic and un-ordered heatmap. 
```{r}
# melt the upper triangle of the correlation matrix.
melted_corr_matrix <- melt(calc_upper_Triangle(corr_mat = corr_matrix), na.rm = TRUE)

# create the basic unordered heatmap plot
unordered_heatmap <- ggplot(data = melted_corr_matrix, aes(Var2, Var1, fill = value)) + 
  geom_tile(color = "white") + 
  scale_fill_gradient2(low = "blue", mid = "white", high = "red",       # setup the colors
                       midpoint = 0, limit = c(-1, 1), space = "Lab",   # setup the ranges
                       name="Diamond\nCorrelation") +                   # title of graph
  theme_minimal() + # setup the theme
  theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 12, hjust = 1)) + 
  coord_fixed()
```

Before we plot the graph, it may be a good idea to add labels to each of the squares.
```{r}
unordered_heatmap +
  geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) + 
  theme( # adding the thematic items
    axis.title.x = element_blank(), axis.title.y = element_blank(),
    panel.grid.major = element_blank(), panel.border = element_blank(),
    panel.background = element_blank(), axis.ticks = element_blank(),
    legend.justification = c(1, 0), legend.position = c(0.55, 0.75), 
    legend.direction = "horizontal") + 
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))
```

Lastly, for heatmaps we can organize the correlation matrix by highest to lowest correlation. This can help in finding any 'hidden' patterns in the correlation of variables. To do this, we will define another helper function that uses **hclust**; ordering the matrix in a hierarchical clustering order. 
```{r}
# reordering a correlation matrix, using hclust
reorder_matrix <- function(corr_mat) {
  dd <- as.dist((1 - corr_mat) / 2)
  hc <- hclust(dd)
  corr_mat <- corr_mat[hc$order, hc$order]
}
```

Similar to the un-ordered heatmap, we are going to truncate the repeating side of the correlation matrix, as it is not needed. Then the correlation matrix is melted before being plotted.
```{r}
# 1. reordering the correlation matrix
corr_matrix <- reorder_matrix(corr_matrix)

# 2. truncate and melt the matrix
melted_corr_matrix <- melt(calc_upper_Triangle(corr_mat = corr_matrix), na.rm = TRUE)

# 3. create the basic plot
ordered_heatmap <- ggplot(data = melted_corr_matrix, aes(Var2, Var1, fill = value)) + 
  geom_tile(color = "white") + 
  scale_fill_gradient2(low = "blue", mid = "white", high = "red",       # setup the colors
                       midpoint = 0, limit = c(-1, 1), space = "Lab",   # setup the ranges
                       name="Diamond\nCorrelation") +                   # title of graph
  theme_minimal() + # setup the theme
  theme(axis.text.x = element_text(angle = 45, vjust = 1, size = 12, hjust = 1)) + 
  coord_fixed()
```

Again, now we can add value labeling to the squares and move the legend.
```{r}
ordered_heatmap +
  geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) + 
  theme( # adding the thematic items
    axis.title.x = element_blank(), axis.title.y = element_blank(),
    panel.grid.major = element_blank(), panel.border = element_blank(),
    panel.background = element_blank(), axis.ticks = element_blank(),
    legend.justification = c(1, 0), legend.position = c(0.55, 0.75), 
    legend.direction = "horizontal") + 
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                               title.position = "top", title.hjust = 0.5))  
```


### Distribution of Columns

Now we can look at the distribution of each of the columns. The following graphs will show a mean line and density plot. **Note: this is with the raw dataset, including the outliers. Some of the next graphs may have un-normalized data, that is skewed.**


#### Carat

First, we will look at the distribution of the carat of the diamond.
```{r}
# mean line plot
plot1 <- ggplot(data = diamonds_raw, aes(x=carat)) +
  geom_histogram(color = "black", fill = "white") + 
  geom_vline(aes(xintercept = mean(carat)),
             color = "blue", linetype="dashed", linewidth = 1)

# density plot
plot2 <- ggplot(data = diamonds_raw, aes(x=carat)) +
  geom_histogram(aes(y=after_stat(density)), color = "black", fill = "white") +
  geom_density(alpha=.2, fill = "red")

# arrange the plots together
grid.arrange(plot1, plot2, ncol=2)
```


#### Cut, Color, and Clarity

Now we will look at the categorical columns of the dataset. however, we must first convert them to a factor. 
```{r}
# convert the cut column into a factor
diamonds_raw$cut <- factor(diamonds_raw$cut, levels = c("Ideal", "Premium", "Very Good", "Good", "Fair"))

# convert the color column to a factor
diamonds_raw$color <- factor(diamonds_raw$color, levels = c("D", "E", "F", "G", "H", "I", "J"))

# convert the clarity column to a factor
diamonds_raw$clarity <- factor(diamonds_raw$clarity, levels = c("IF", "VVS1", "VVS2", "VS1", "VS2", "SI1", "SI2", "I1"))
```



With the columns converted, we can make the charts. 
```{r}
# chart for the cut
plot1 <- ggplot(data = diamonds_raw, aes(x=cut, fill=cut)) +
  geom_bar() + 
  labs(x = "Cut") + 
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

# chart for the color
plot2 <- ggplot(data = diamonds_raw, aes(x=color, fill=color)) +
  geom_bar() + labs(x = "Color")

# chart for the clarity
plot3 <- ggplot(data = diamonds_raw, aes(x=clarity, fill=clarity)) +
  geom_bar() + labs(x = "Clarity") + 
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

grid.arrange(plot1, plot2, plot3, ncol = 2, nrow = 2)
```

From the charts above, we can infer some conclusions about the data in these columns.

 1. The cut column is skewed to the left, and is not in a normal distribution. 
 2. It looks like the color column has a more normal distribution than the cut column, however, the data still has a slight skew to the left.
 3. Similar to the color column, the clarity column is roughly normal, however, the column still has a slight skew to the right.


#### Depth & Table

Now, we can look at the table and depth ratios. 
```{r}
# mean line plot of depth
plot1 <- ggplot(data = diamonds_raw, aes(x=depth)) +
  geom_histogram(color = "black", fill = "white") + 
  geom_vline(aes(xintercept = mean(depth)),
             color = "blue", linetype="dashed", linewidth = 1)

# density plot depth
plot2 <- ggplot(data = diamonds_raw, aes(x=depth)) +
  geom_histogram(aes(y=after_stat(density)), color = "black", fill = "white") +
  geom_density(alpha=.2, fill = "red")


# mean line for table
plot3 <- ggplot(data = diamonds_raw, aes(x=table)) +
  geom_histogram(color = "black", fill = "white") + 
  geom_vline(aes(xintercept = mean(table)),
             color = "blue", linetype="dashed", linewidth = 1)

# density plot depth
plot4 <- ggplot(data = diamonds_raw, aes(x=table)) +
  geom_histogram(aes(y=after_stat(density)), color = "black", fill = "white") +
  geom_density(alpha=.2, fill = "red")

# arrange the plots together
grid.arrange(plot1, plot2, plot3, plot4, ncol=2, nrow = 2)
```

Using the graphs above, the table and depth are roughly normal, they just have a steep slope to the bell curve. 

#### x, y, & z

The last of the single column charts are the x, y, and z measurements of the diamond.

```{r}
# mean line for x
plot1 <- ggplot(data = diamonds_raw, aes(x=x)) +
  geom_histogram(color = "black", fill = "white") + 
  geom_vline(aes(xintercept = mean(x)),
             color = "blue", linetype="dashed", linewidth = 1)

# density plot x
plot2 <- ggplot(data = diamonds_raw, aes(x=x)) +
  geom_histogram(aes(y=after_stat(density)), color = "black", fill = "white") +
  geom_density(alpha=.2, fill = "red")


# mean line for y
plot3 <- ggplot(data = diamonds_raw, aes(x=y)) +
  geom_histogram(color = "black", fill = "white") + 
  geom_vline(aes(xintercept = mean(y)),
             color = "blue", linetype="dashed", linewidth = 1)

# density plot y
plot4 <- ggplot(data = diamonds_raw, aes(x=y)) +
  geom_histogram(aes(y=after_stat(density)), color = "black", fill = "white") +
  geom_density(alpha=.2, fill = "red")


# mean line for z
plot5 <- ggplot(data = diamonds_raw, aes(x=z)) +
  geom_histogram(color = "black", fill = "white") + 
  geom_vline(aes(xintercept = mean(z)),
             color = "blue", linetype="dashed", linewidth = 1)

# density plot z
plot6 <- ggplot(data = diamonds_raw, aes(x=z)) +
  geom_histogram(aes(y=after_stat(density)), color = "black", fill = "white") +
  geom_density(alpha=.2, fill = "red")

grid.arrange(plot1, plot2, plot3, plot4, plot5, plot6, ncol=2, nrow = 3)
```

From the charts above, we can infer some basic conclusions about the data.

 1. The values for x, y, and z are roughly normal.
 2. X has a bias to the left and right of the mean line, and there are most likely some outliers to the left and right of the mean.
 3. y seems to have some large outliers to the right of the mean line.
 4. Z also seems to hame some large outliers to the right of the mena line.


### Comparing Variables

Now we will start to compare two different variables, to see if there are any trends in the data. This can be a decent tool in deciding what columns to include in our models. 

#### Cut vs. Color

Let's first start with the cut vs color. 
```{r}
plot1 <- ggplot(data = diamonds_raw, mapping = aes(x = cut)) + 
  layer(geom = "bar", mapping = aes(fill = color), stat = "count", position = "stack")

plot2 <- ggplot(data = diamonds_raw, mapping = aes(x = color)) + 
  layer(geom = "bar", mapping = aes(fill = cut), stat = "count", position = "stack")

grid.arrange(plot1, plot2, ncol=2)
```


#### Cut vs. Clarity

Now, we will look at the comparison of the cut and clarity.
```{r}
plot1 <- ggplot(data = diamonds_raw, mapping = aes(x = cut)) + 
  layer(geom = "bar", mapping = aes(fill = clarity), stat = "count", position = "stack")

plot2 <- ggplot(data = diamonds_raw, mapping = aes(x = clarity)) + 
  layer(geom = "bar", mapping = aes(fill = cut), stat = "count", position = "stack")

grid.arrange(plot1, plot2, ncol=2)
```

#### Color vs. Clarity

Lastly, we will look at the color vs clarity
```{r}
plot1 <- ggplot(data = diamonds_raw, mapping = aes(x = color)) + 
  layer(geom = "bar", mapping = aes(fill = clarity), stat = "count", position = "stack")

plot2 <- ggplot(data = diamonds_raw, mapping = aes(x = clarity)) + 
  layer(geom = "bar", mapping = aes(fill = color), stat = "count", position = "stack")

grid.arrange(plot1, plot2, ncol=2)
```



### Handling outliers in the dataset
```{r}
#Visualizing outliers in the dataset
boxplot(diamonds_raw$carat)
boxplot(diamonds_raw$depth)
boxplot(diamonds_raw$table)
boxplot(diamonds_raw$x)
boxplot(diamonds_raw$y)
boxplot(diamonds_raw$z)
```


<<<<<<< HEAD

### Handling outliers

<<<<<<< HEAD
Summary of data before handling outlier
```{r}
summary(diamonds_raw)
```

Carat outliers
=======
=======
>>>>>>> 0e086a80f2bf5541ce231bf083ef90d668568300
#### Carat outliers
>>>>>>> 8c65332fe2e5de5ac4b9af4f7ddfe1475bccb850
```{r}
boxplot(diamonds_raw$carat)

#Carat outlier removal
the_mean <- mean(as.numeric(diamonds_raw$carat))
the_sd <- sd(as.numeric(diamonds_raw$carat))

diamond_outliers1 <- diamonds_raw |>
  mutate(zscore = (carat - the_mean)/the_sd) |>
  filter(zscore <= 3 & zscore >= -3)

summary(diamond_outliers1$carat) #Lost 439 records which is only 0.81% of the data
```

#### Depth outliers
```{r}
boxplot(diamonds_raw$depth)

#Depth outlier removal
the_mean <- mean(as.numeric(diamonds_raw$depth))
the_sd <- sd(as.numeric(diamonds_raw$depth))

diamond_outliers2 <- diamond_outliers1 |>
  mutate(zscore = (depth - the_mean)/the_sd) |>
  filter(zscore <= 3 & zscore >= -3)

summary(diamond_outliers2$depth) #Lost 663 records which is a cumulative percentage of 2.04% of the total dataset and 1.24% percent of the outlier1 data set
```

#### Table outliers
```{r}
boxplot(diamonds_raw$table)

#Table outlier removal
the_mean <- mean(as.numeric(diamonds_raw$table))
the_sd <- sd(as.numeric(diamonds_raw$table))

diamond_outliers3 <- diamond_outliers2 |>
  mutate(zscore = (table - the_mean)/the_sd) |>
  filter(zscore <= 3 & zscore >= -3)

summary(diamond_outliers3$table) #Lost 264 records which is a cumulative percentage of 2.53% of the total dataset and 0.5% percent of the outlier2 data set
```

#### X outliers
```{r}
boxplot(diamonds_raw$x)

#X outlier removal
the_mean <- mean(as.numeric(diamonds_raw$x))
the_sd <- sd(as.numeric(diamonds_raw$x))

diamond_outliers4 <- diamond_outliers3 |>
  mutate(zscore = (x - the_mean)/the_sd) |>
  filter(zscore <= 3 & zscore >= -3)

summary(diamond_outliers4$x) #Lost 6 records which is a cumulative percentage of 2.54% of the total dataset and 0.01% percent of the outlier2 data set
```

#### Y outliers
```{r}
boxplot(diamonds_raw$y)

#y
the_mean <- mean(as.numeric(diamonds_raw$y))
the_sd <- sd(as.numeric(diamonds_raw$y))

diamond_outliers5 <- diamond_outliers4 |>
  mutate(zscore = (y - the_mean)/the_sd) |>
  filter(zscore <= 3 & zscore >= -3)

summary(diamond_outliers5$y) #Lost 2 records which is a cumulative percentage of 2.547% of the total dataset and 0.004% percent of the outlier2 data set
```

#### Z outliers
```{r}
boxplot(diamonds_raw$z)

#z
the_mean <- mean(as.numeric(diamonds_raw$z))
the_sd <- sd(as.numeric(diamonds_raw$z))

diamond_outliers6 <- diamond_outliers5 |>
  mutate(zscore = (z - the_mean)/the_sd) |>
  filter(zscore <= 3 & zscore >= -3)

summary(diamond_outliers6$z) #Lost 14 records which is a cumulative percentage of 2.60% of the total dataset and 0.03% percent of the outlier2 data set
```
<<<<<<< HEAD






=======
>>>>>>> 8c65332fe2e5de5ac4b9af4f7ddfe1475bccb850
